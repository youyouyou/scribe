//  Copyright (c) 2007-2009 Facebook
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
// See accompanying file LICENSE or visit the Scribe site at:
// http://developers.facebook.com/scribe/
//
// @author Satish Mittal

#ifndef SCRIBE_AUDIT_H
#define SCRIBE_AUDIT_H

#include "common.h"
#include "src/gen-cpp/audit_types.h"

// This struct holds audit stats for msgs received/sent for a given topic 
struct AuditMsg {
  // an instance of audit msg is created per topic
  std::string topic;
  // received map with key as msg generation timestamp extracted from msg header 
  // and value as number of msgs with that timestamp that are received
  std::map<long, long> received;
  // sent map with key as msg generation timestamp extracted from msg header 
  // and value as number of msgs with that timestamp that are sent
  std::map<long, long> sent;
  // total msgs received for this topic since last audit
  unsigned long long receivedCount;
  // total msgs sent for this topic since last audit
  unsigned long long sentCount;
  pthread_mutex_t mutex;
};

// This struct holds audit stats for mgs written in a given file for a topic
struct FileAuditMsg {
  // an instance of file audit msg is created per file name 
  std::string filename;
  // topic on which msgs are written in the file
  std::string topic;
  // received map with key as msg generation timestamp extracted from msg header 
  // and value as number of msgs with that timestamp that are received
  std::map<long, long> received;
  // total msgs received by file store tier for this topic since last file audit
  unsigned long long receivedCount;
  // whether this file has been closed. File audit msg will be generated by 
  // audit store thread only after file is marked as closed.
  bool fileClosed;
};

typedef AuditMsg audit_msg_t;
typedef FileAuditMsg file_audit_msg_t;

// this audit map has key as category and value as audit_msg_t instance
typedef std::map<std::string, boost::shared_ptr<audit_msg_t> > audit_map_t;
// this audit map has key as filename and value as file_audit_msg_t instance
typedef std::map<std::string, boost::shared_ptr<file_audit_msg_t> > file_audit_map_t;

class StoreQueue;

// constant string for the name of special audit topic used internally by databus to 
// generate audit messages for various tiers
static const std::string auditTopic = "_audit";

class AuditManager  {
 public:
  AuditManager(const boost::shared_ptr<StoreQueue> pAuditStore);
  ~AuditManager();

  // This method audits the event that a message is received/sent 
  void auditMessage(const scribe::thrift::LogEntry& entry, bool received);
  
  // This method audits the event that a batch of messages are received/sent. If it is
  // a case of messages being sent to a file store and auditFileStore flag is set true,
  // this method also audits on behalf of file store tier that the file store
  // received these messages.
  void auditMessages(boost::shared_ptr<logentry_vector_t>& messages, unsigned long offset,
       unsigned long count, const std::string& category, bool received, bool auditFileStore, 
       const std::string& filename);
  
  // This method audits the event that the given file is closed. This would allow audit 
  // store thread to generate audit message for this file.
  void auditFileClosed(const std::string& filename);
  
  // This method is called by audit store thread periodically to generate audit messages
  // for all categories/file stores and add them to message queue. 
  void performAuditTask();
  
 private:
  // Get the audit message entry in audit map for the given category. If the entry is not
  // found, this method adds an entry and returns it.
  boost::shared_ptr<audit_msg_t> getAuditMsg(const std::string& category);
  
  // Get the file audit message entry in file audit map for the given filename/category.
  // If the entry is not found, this method adds an entry and returns it.
  boost::shared_ptr<file_audit_msg_t> getFileAuditMsg(const std::string& filename, 
       const std::string& category);
  
  // This method checks whether the given message has a valid header. If a valid header is
  // found, this method returns timestamp key else returns 0.
  unsigned long long validateMessageAndGetTimestamp(const scribe::thrift::LogEntry& entry);
  
  // This method updates the sent/received counter for the given message entry and its 
  // corresponding timestamp key in the sent/received map.
  void updateAuditMessageCounter(boost::shared_ptr<audit_msg_t>& audit_msg,
      unsigned long long timestampKey, bool received);
  
  // This method updates the received counter for the given message entry and its 
  // corresponding timestamp key in the received map. This method will be called
  // only when messages are sent to a file store and auditFileStore flag is enabled.
  void updateFileAuditMessageCounter(boost::shared_ptr<file_audit_msg_t>& file_audit_msg,
      unsigned long long timestampKey);
  
  // This method serializes the audit message entry and sets it as the message payload
  // of a logEntry instance. This instance will be later added in the audit thread queue.
  logentry_ptr_t serializeAuditMsg(boost::shared_ptr<audit_msg_t>& audit_msg,
      long timeInMillis);
  
  // This method serializes the file audit message entry and sets it as the message payload
  // of a logEntry instance. This instance will be later added in the audit thread queue.
  logentry_ptr_t serializeFileAuditMsg(boost::shared_ptr<file_audit_msg_t>& file_audit_msg,
      long timeInMillis);
 
  // audit store that uses the audit manager instance to periodically generate audit messages
  // from its in-memory maps and then send them downstream.
  boost::shared_ptr<StoreQueue> auditStore;
  // Host name where scribe is running. This will be set as a field in the Audit message
  std::string hostName;
  // The tier for which Audit messages are being generated. Its possible values are 'agent',
  // 'collector' or 'hdfs'
  std::string tier;
  // The time window size used to bucket the messages inside received/sent map within audit msg.
  // E.g. if window size is 60 seconds, then messages whose generation timestamp lies within 
  // 12:00 and 12:59 would be counted in the same bucket whose key is 12:00
  long int windowSize;
  // Instance of audit map 
  audit_map_t auditMap;
  // Instance of file audit map 
  file_audit_map_t fileAuditMap;
  // Instance of read-write mutex used to synchronize various operations on audit map
  // and file audit map owned by audit manager class.
  boost::shared_ptr<apache::thrift::concurrency::ReadWriteMutex> auditRWMutex;
};

#endif //!defined SCRIBE_AUDIT_H
